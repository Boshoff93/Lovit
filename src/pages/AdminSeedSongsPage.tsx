import React, { useState, useCallback, useEffect, useRef } from 'react';
import {
  Box,
  Container,
  Typography,
  Paper,
  Button,
  CircularProgress,
  Tabs,
  Tab,
  Chip,
  LinearProgress,
  Alert,
  Snackbar,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  IconButton,
  Tooltip,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import ContentCopyIcon from '@mui/icons-material/ContentCopy';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import ErrorIcon from '@mui/icons-material/Error';
import MusicNoteIcon from '@mui/icons-material/MusicNote';
import RefreshIcon from '@mui/icons-material/Refresh';
import { useSelector } from 'react-redux';
import { RootState } from '../store/store';
import { songsApi } from '../services/api';
import { 
  genreSeedSongs, 
  moodSeedSongs, 
  SeedSong,
  getAllGenreIds,
  getAllMoodIds,
  getTotalGenreSongs,
  getTotalMoodSongs,
} from '../data/seedSongs';

interface GeneratedSong extends SeedSong {
  songId?: string;
  actualTitle?: string; // The title generated by Claude
  songStatus?: 'processing' | 'completed' | 'failed'; // Backend status
  status: 'pending' | 'generating' | 'success' | 'error';
  errorMessage?: string;
}

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;
  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`seed-tabpanel-${index}`}
      aria-labelledby={`seed-tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ py: 3 }}>{children}</Box>}
    </div>
  );
}

const AdminSeedSongsPage: React.FC = () => {
  const { user } = useSelector((state: RootState) => state.auth);
  const [tabValue, setTabValue] = useState(0);
  const [generatingAll, setGeneratingAll] = useState(false);
  const [progress, setProgress] = useState(0);
  const [totalToGenerate, setTotalToGenerate] = useState(0);
  
  // Track generated songs with their IDs
  const [genreResults, setGenreResults] = useState<Record<string, GeneratedSong[]>>({});
  const [moodResults, setMoodResults] = useState<Record<string, GeneratedSong[]>>({});
  
  const [notification, setNotification] = useState<{
    open: boolean;
    message: string;
    severity: 'success' | 'error' | 'info';
  }>({ open: false, message: '', severity: 'info' });
  
  const [isPolling, setIsPolling] = useState(false);
  const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null);

  const handleTabChange = (_: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
  };
  
  // Backend song type
  interface BackendSong {
    songId: string;
    songTitle: string;
    status: 'processing' | 'completed' | 'failed';
  }
  
  // Fetch all songs and update with actual titles
  const fetchAndUpdateSongs = useCallback(async () => {
    if (!user?.userId) return;
    
    try {
      const response = await songsApi.getUserSongs(user.userId);
      const songs: BackendSong[] = response.data?.songs || [];
      
      // Create a map of songId -> song data
      const songMap = new Map<string, BackendSong>(songs.map((s) => [s.songId, s]));
      
      // Update genre results
      setGenreResults(prev => {
        const updated = { ...prev };
        Object.keys(updated).forEach(categoryId => {
          updated[categoryId] = updated[categoryId].map(song => {
            if (song.songId && songMap.has(song.songId)) {
              const backendSong = songMap.get(song.songId)!;
              return {
                ...song,
                actualTitle: backendSong.songTitle !== 'Generating...' ? backendSong.songTitle : undefined,
                songStatus: backendSong.status,
              };
            }
            return song;
          });
        });
        return updated;
      });
      
      // Update mood results
      setMoodResults(prev => {
        const updated = { ...prev };
        Object.keys(updated).forEach(categoryId => {
          updated[categoryId] = updated[categoryId].map(song => {
            if (song.songId && songMap.has(song.songId)) {
              const backendSong = songMap.get(song.songId)!;
              return {
                ...song,
                actualTitle: backendSong.songTitle !== 'Generating...' ? backendSong.songTitle : undefined,
                songStatus: backendSong.status,
              };
            }
            return song;
          });
        });
        return updated;
      });
      
      // Check if any songs are still processing
      const allGenreSongs = Object.values(genreResults).flat();
      const allMoodSongs = Object.values(moodResults).flat();
      const allSongs = [...allGenreSongs, ...allMoodSongs];
      const hasProcessing = allSongs.some(s => s.songId && (!s.actualTitle || s.songStatus === 'processing'));
      
      return hasProcessing;
    } catch (error) {
      console.error('Error fetching songs:', error);
      return false;
    }
  }, [user?.userId, genreResults, moodResults]);
  
  // Start/stop polling
  const togglePolling = useCallback(() => {
    if (isPolling) {
      // Stop polling
      if (pollingIntervalRef.current) {
        clearInterval(pollingIntervalRef.current);
        pollingIntervalRef.current = null;
      }
      setIsPolling(false);
    } else {
      // Start polling
      setIsPolling(true);
      fetchAndUpdateSongs(); // Fetch immediately
      pollingIntervalRef.current = setInterval(async () => {
        const hasProcessing = await fetchAndUpdateSongs();
        if (!hasProcessing) {
          // Stop polling when all songs are complete
          if (pollingIntervalRef.current) {
            clearInterval(pollingIntervalRef.current);
            pollingIntervalRef.current = null;
          }
          setIsPolling(false);
          setNotification({
            open: true,
            message: 'All songs finished generating!',
            severity: 'success'
          });
        }
      }, 5000); // Poll every 5 seconds
    }
  }, [isPolling, fetchAndUpdateSongs]);
  
  // Cleanup polling on unmount
  useEffect(() => {
    return () => {
      if (pollingIntervalRef.current) {
        clearInterval(pollingIntervalRef.current);
      }
    };
  }, []);

  // Generate a single song
  const generateSong = async (song: SeedSong, type: 'genre' | 'mood', categoryId: string): Promise<GeneratedSong> => {
    if (!user?.userId) {
      return { ...song, status: 'error', errorMessage: 'Not logged in' };
    }

    try {
      const response = await songsApi.generateSong({
        userId: user.userId,
        songPrompt: song.prompt,
        genre: song.genre,
        mood: song.mood,
        language: song.language,
      });

      // Response structure: { success, song: { songId, ... }, tokensUsed, tokensRemaining }
      const songId = response.data?.song?.songId;
      
      console.log(`‚úÖ Generated ${type} song for ${categoryId}:`, {
        title: song.title,
        songId,
        genre: song.genre,
        mood: song.mood,
        prompt: song.prompt.substring(0, 50) + '...',
      });

      return { 
        ...song, 
        songId, 
        status: 'success' 
      };
    } catch (error: any) {
      const errorMessage = error.response?.data?.error || error.message || 'Unknown error';
      console.error(`‚ùå Failed to generate ${type} song for ${categoryId}:`, {
        title: song.title,
        error: errorMessage,
      });
      return { 
        ...song, 
        status: 'error', 
        errorMessage 
      };
    }
  };

  // Generate all songs for a category
  const generateCategorySongs = async (
    categoryId: string, 
    songs: SeedSong[], 
    type: 'genre' | 'mood',
    setResults: React.Dispatch<React.SetStateAction<Record<string, GeneratedSong[]>>>
  ) => {
    // Mark all songs as generating
    setResults(prev => ({
      ...prev,
      [categoryId]: songs.map(s => ({ ...s, status: 'generating' as const }))
    }));

    const results: GeneratedSong[] = [];
    
    for (let i = 0; i < songs.length; i++) {
      const result = await generateSong(songs[i], type, categoryId);
      results.push(result);
      
      // Update results as we go
      setResults(prev => ({
        ...prev,
        [categoryId]: [...results, ...songs.slice(i + 1).map(s => ({ ...s, status: 'pending' as const }))]
      }));
      
      // Small delay between generations to avoid rate limiting
      if (i < songs.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Final update
    setResults(prev => ({
      ...prev,
      [categoryId]: results
    }));

    return results;
  };

  // Generate all genre songs
  const generateAllGenreSongs = async () => {
    const genreIds = getAllGenreIds();
    const total = getTotalGenreSongs();
    setTotalToGenerate(total);
    setProgress(0);
    setGeneratingAll(true);

    let completed = 0;

    for (const genreId of genreIds) {
      const songs = genreSeedSongs[genreId];
      await generateCategorySongs(genreId, songs, 'genre', setGenreResults);
      completed += songs.length;
      setProgress((completed / total) * 100);
    }

    setGeneratingAll(false);
    logAllResults('genre', genreResults);
  };

  // Generate all mood songs
  const generateAllMoodSongs = async () => {
    const moodIds = getAllMoodIds();
    const total = getTotalMoodSongs();
    setTotalToGenerate(total);
    setProgress(0);
    setGeneratingAll(true);

    let completed = 0;

    for (const moodId of moodIds) {
      const songs = moodSeedSongs[moodId];
      await generateCategorySongs(moodId, songs, 'mood', setMoodResults);
      completed += songs.length;
      setProgress((completed / total) * 100);
    }

    setGeneratingAll(false);
    logAllResults('mood', moodResults);
  };

  // Log all results for easy copying
  const logAllResults = (type: string, results: Record<string, GeneratedSong[]>) => {
    console.log(`\n========================================`);
    console.log(`üìã ALL ${type.toUpperCase()} SONG IDS:`);
    console.log(`========================================`);
    
    Object.entries(results).forEach(([categoryId, songs]) => {
      console.log(`\n// ${categoryId.toUpperCase()}`);
      songs.forEach((song) => {
        if (song.songId) {
          // Use actual title from backend if available
          const displayTitle = song.actualTitle || song.title;
          console.log(`{ id: '${song.songId}', title: '${displayTitle}', duration: 'TBD', plays: '0' },`);
        }
      });
    });
    
    console.log(`\n========================================\n`);
  };

  // Copy results to clipboard
  const copyResultsToClipboard = useCallback((type: 'genre' | 'mood') => {
    const results = type === 'genre' ? genreResults : moodResults;
    let text = `// ${type.toUpperCase()} SAMPLE TRACKS\n\n`;
    
    Object.entries(results).forEach(([categoryId, songs]) => {
      text += `'${categoryId}': [\n`;
      songs.forEach((song) => {
        if (song.songId) {
          // Use actual title from backend if available, otherwise use original title
          const displayTitle = song.actualTitle || song.title;
          text += `  { id: '${song.songId}', title: '${displayTitle}', duration: 'TBD', plays: '0' },\n`;
        }
      });
      text += `],\n\n`;
    });

    navigator.clipboard.writeText(text);
    setNotification({
      open: true,
      message: `${type.charAt(0).toUpperCase() + type.slice(1)} results copied to clipboard!`,
      severity: 'success'
    });
  }, [genreResults, moodResults]);

  // Generate a single song and update state
  const generateSingleSong = async (
    song: SeedSong,
    songIndex: number,
    categoryId: string,
    type: 'genre' | 'mood',
    setResults: React.Dispatch<React.SetStateAction<Record<string, GeneratedSong[]>>>
  ) => {
    const sourceData = type === 'genre' ? genreSeedSongs : moodSeedSongs;
    const allSongs = sourceData[categoryId];
    
    // Mark this specific song as generating
    setResults(prev => {
      const existing = prev[categoryId] || allSongs.map(s => ({ ...s, status: 'pending' as const }));
      const updated = [...existing];
      updated[songIndex] = { ...updated[songIndex], status: 'generating' };
      return { ...prev, [categoryId]: updated };
    });

    const result = await generateSong(song, type, categoryId);

    // Update this specific song with result
    setResults(prev => {
      const existing = prev[categoryId] || allSongs.map(s => ({ ...s, status: 'pending' as const }));
      const updated = [...existing];
      updated[songIndex] = result;
      return { ...prev, [categoryId]: updated };
    });

    return result;
  };

  // Render song card with individual generate button
  const renderSongCard = (
    song: GeneratedSong, 
    index: number,
    categoryId: string,
    type: 'genre' | 'mood',
    setResults: React.Dispatch<React.SetStateAction<Record<string, GeneratedSong[]>>>
  ) => {
    const statusIcon = {
      pending: <Chip size="small" label="Pending" color="default" />,
      generating: <CircularProgress size={20} />,
      success: <CheckCircleIcon color="success" />,
      error: <ErrorIcon color="error" />,
    }[song.status];

    const sourceData = type === 'genre' ? genreSeedSongs : moodSeedSongs;
    const originalSong = sourceData[categoryId][index];

    return (
      <Paper
        key={index}
        elevation={0}
        sx={{
          p: 2,
          mb: 1,
          borderRadius: '12px',
          border: '1px solid',
          borderColor: song.status === 'error' ? 'error.main' : 'divider',
          background: song.status === 'success' ? 'rgba(76, 175, 80, 0.05)' : 'white',
        }}
      >
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
          <MusicNoteIcon sx={{ color: '#007AFF' }} />
          <Box sx={{ flex: 1 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
              <Typography fontWeight={600}>{song.title}</Typography>
              {song.actualTitle && song.actualTitle !== song.title && (
                <Chip 
                  label={song.actualTitle} 
                  size="small" 
                  color="primary" 
                  variant="outlined"
                  sx={{ fontSize: '0.7rem' }}
                />
              )}
              {song.songStatus === 'processing' && (
                <Chip label="Processing..." size="small" color="warning" sx={{ fontSize: '0.7rem' }} />
              )}
            </Box>
            <Typography variant="body2" color="text.secondary" sx={{ 
              overflow: 'hidden', 
              textOverflow: 'ellipsis', 
              whiteSpace: 'nowrap',
              maxWidth: 400,
            }}>
              {song.prompt}
            </Typography>
            {song.songId && (
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mt: 0.5 }}>
                <Typography variant="caption" sx={{ color: 'success.main', fontFamily: 'monospace' }}>
                  ID: {song.songId}
                </Typography>
                <Tooltip title="Copy ID">
                  <IconButton 
                    size="small" 
                    onClick={() => {
                      navigator.clipboard.writeText(song.songId!);
                      setNotification({ open: true, message: 'Song ID copied!', severity: 'success' });
                    }}
                    sx={{ p: 0.25 }}
                  >
                    <ContentCopyIcon sx={{ fontSize: 14 }} />
                  </IconButton>
                </Tooltip>
              </Box>
            )}
            {song.errorMessage && (
              <Typography variant="caption" color="error">
                Error: {song.errorMessage}
              </Typography>
            )}
          </Box>
          <Chip label={song.genre} size="small" />
          <Chip label={song.mood} size="small" variant="outlined" />
          
          {/* Individual generate button */}
          {(song.status === 'pending' || song.status === 'error') && !generatingAll && (
            <Tooltip title="Generate this song">
              <IconButton
                size="small"
                onClick={() => generateSingleSong(originalSong, index, categoryId, type, setResults)}
                sx={{
                  background: '#007AFF',
                  color: 'white',
                  '&:hover': { background: '#0056b3' },
                }}
              >
                <PlayArrowIcon sx={{ fontSize: 18 }} />
              </IconButton>
            </Tooltip>
          )}
          
          {statusIcon}
        </Box>
      </Paper>
    );
  };

  // Render category accordion
  const renderCategoryAccordion = (
    categoryId: string, 
    songs: SeedSong[], 
    type: 'genre' | 'mood',
    results: Record<string, GeneratedSong[]>,
    setResults: React.Dispatch<React.SetStateAction<Record<string, GeneratedSong[]>>>
  ) => {
    const categoryResults = results[categoryId] || songs.map(s => ({ ...s, status: 'pending' as const }));
    const successCount = categoryResults.filter(s => s.status === 'success').length;
    const isGenerating = categoryResults.some(s => s.status === 'generating');

    return (
      <Accordion key={categoryId} sx={{ mb: 1 }}>
        <AccordionSummary expandIcon={<ExpandMoreIcon />}>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, width: '100%', pr: 2 }}>
            <Typography fontWeight={600} sx={{ textTransform: 'capitalize', minWidth: 120 }}>
              {categoryId.replace('-', ' ')}
            </Typography>
            <Chip 
              label={`${successCount}/${songs.length} generated`} 
              size="small" 
              color={successCount === songs.length ? 'success' : 'default'}
            />
            {!isGenerating && !generatingAll && (
              <Button
                size="small"
                startIcon={<PlayArrowIcon />}
                onClick={(e) => {
                  e.stopPropagation();
                  generateCategorySongs(categoryId, songs, type, setResults);
                }}
                sx={{ ml: 'auto' }}
              >
                Generate
              </Button>
            )}
            {isGenerating && <CircularProgress size={20} sx={{ ml: 'auto' }} />}
          </Box>
        </AccordionSummary>
        <AccordionDetails>
          {categoryResults.map((song, index) => renderSongCard(song, index, categoryId, type, setResults))}
        </AccordionDetails>
      </Accordion>
    );
  };

  if (!user?.userId) {
    return (
      <Container maxWidth="md" sx={{ py: 4 }}>
        <Alert severity="warning">
          You must be logged in to access this page.
        </Alert>
      </Container>
    );
  }

  return (
    <Box sx={{ minHeight: '100vh', background: '#f5f5f7', py: 4 }}>
      <Container maxWidth="lg">
        <Paper
          elevation={0}
          sx={{
            p: 4,
            borderRadius: '24px',
            background: 'rgba(255,255,255,0.9)',
            backdropFilter: 'blur(20px)',
          }}
        >
          {/* Header */}
          <Box sx={{ mb: 4 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 }}>
              <Typography variant="h4" fontWeight={700}>
                üéµ Seed Songs Generator
              </Typography>
              <Box sx={{ display: 'flex', gap: 1 }}>
                <Button
                  variant={isPolling ? 'contained' : 'outlined'}
                  startIcon={isPolling ? <CircularProgress size={16} color="inherit" /> : <RefreshIcon />}
                  onClick={togglePolling}
                  color={isPolling ? 'warning' : 'primary'}
                  sx={{ textTransform: 'none', borderRadius: '12px' }}
                >
                  {isPolling ? 'Stop Polling' : 'Start Polling (Fetch Titles)'}
                </Button>
                <Tooltip title="Refresh once">
                  <IconButton onClick={() => fetchAndUpdateSongs()}>
                    <RefreshIcon />
                  </IconButton>
                </Tooltip>
              </Box>
            </Box>
            <Typography color="text.secondary">
              Generate sample songs for each genre and mood. Click "Start Polling" to fetch actual song titles from backend.
            </Typography>
          </Box>

          {/* Progress bar when generating all */}
          {generatingAll && (
            <Box sx={{ mb: 3 }}>
              <Typography variant="body2" gutterBottom>
                Generating songs... {Math.round(progress)}%
              </Typography>
              <LinearProgress variant="determinate" value={progress} />
            </Box>
          )}

          {/* Tabs */}
          <Tabs value={tabValue} onChange={handleTabChange} sx={{ mb: 2 }}>
            <Tab label={`Genres (${getTotalGenreSongs()} songs)`} />
            <Tab label={`Moods (${getTotalMoodSongs()} songs)`} />
          </Tabs>

          {/* Genre Tab */}
          <TabPanel value={tabValue} index={0}>
            <Box sx={{ display: 'flex', gap: 2, mb: 3 }}>
              <Button
                variant="contained"
                startIcon={<PlayArrowIcon />}
                onClick={generateAllGenreSongs}
                disabled={generatingAll}
                sx={{
                  background: '#007AFF',
                  borderRadius: '12px',
                  textTransform: 'none',
                  fontWeight: 600,
                }}
              >
                Generate All Genre Songs
              </Button>
              <Tooltip title="Copy all generated IDs to clipboard">
                <IconButton 
                  onClick={() => copyResultsToClipboard('genre')}
                  disabled={Object.keys(genreResults).length === 0}
                >
                  <ContentCopyIcon />
                </IconButton>
              </Tooltip>
            </Box>

            {getAllGenreIds().map(genreId => 
              renderCategoryAccordion(
                genreId, 
                genreSeedSongs[genreId], 
                'genre',
                genreResults,
                setGenreResults
              )
            )}
          </TabPanel>

          {/* Mood Tab */}
          <TabPanel value={tabValue} index={1}>
            <Box sx={{ display: 'flex', gap: 2, mb: 3 }}>
              <Button
                variant="contained"
                startIcon={<PlayArrowIcon />}
                onClick={generateAllMoodSongs}
                disabled={generatingAll}
                sx={{
                  background: '#007AFF',
                  borderRadius: '12px',
                  textTransform: 'none',
                  fontWeight: 600,
                }}
              >
                Generate All Mood Songs
              </Button>
              <Tooltip title="Copy all generated IDs to clipboard">
                <IconButton 
                  onClick={() => copyResultsToClipboard('mood')}
                  disabled={Object.keys(moodResults).length === 0}
                >
                  <ContentCopyIcon />
                </IconButton>
              </Tooltip>
            </Box>

            {getAllMoodIds().map(moodId => 
              renderCategoryAccordion(
                moodId, 
                moodSeedSongs[moodId], 
                'mood',
                moodResults,
                setMoodResults
              )
            )}
          </TabPanel>

          {/* Instructions */}
          <Paper 
            elevation={0} 
            sx={{ 
              p: 3, 
              mt: 4, 
              borderRadius: '16px', 
              background: 'rgba(0,122,255,0.05)',
              border: '1px solid rgba(0,122,255,0.1)'
            }}
          >
            <Typography variant="h6" fontWeight={600} gutterBottom>
              üìã How to Use
            </Typography>
            <Typography component="ol" sx={{ pl: 2 }}>
              <li>Click "Generate" for individual categories or "Generate All" for bulk generation</li>
              <li>Open the browser console (F12) to see the generated song IDs</li>
              <li>Use the copy button to copy all IDs in the correct format</li>
              <li>Update the sample tracks in <code>GenreDetailPage.tsx</code> and <code>MoodDetailPage.tsx</code></li>
              <li>Wait for songs to finish generating in the backend (check your library)</li>
            </Typography>
          </Paper>
        </Paper>
      </Container>

      <Snackbar
        open={notification.open}
        autoHideDuration={4000}
        onClose={() => setNotification(prev => ({ ...prev, open: false }))}
      >
        <Alert severity={notification.severity} onClose={() => setNotification(prev => ({ ...prev, open: false }))}>
          {notification.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default AdminSeedSongsPage;

